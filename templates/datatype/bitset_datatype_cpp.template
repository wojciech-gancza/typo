// WARNING: File generated automatically by 'typo'. 
//   copyright:       ${copyright}
//   generated from:  ${source_script_file_name} line ${source_script_file_line}
//   generated at:    ${timestamp}
// Do not modify manually outside spaces marked as manually added by programmer


#include "${type_name.lowercase_with_underscores}.h"

#include <sstream>

// additional code (manually added by programmer)
${user_code}
// end of additional includes

${type_name.UppercaseCamel} ${type_name.UppercaseCamel}::from_string(const std::string & p_${type_name.lowercaseCamel}, char separator)
{
    size_t start_of_string = 0;
    ${bitset_carrier_type} value = 0;
    for (int position = p_${type_name.lowercaseCamel}.find(separator); position != std::string::npos; position = p_${type_name.lowercaseCamel}.find(separator, start_of_string))
    {
        std::string element = p_${type_name.lowercaseCamel}.substr(start_of_string, position-start_of_string);
        ${bitset_carrier_type} bit_value = string_to_bit_with_check(element);
        if (!bit_value)
            return ${type_name.UppercaseCamel}(0);
	value |= bit_value;
        start_of_string = position+1;
    }
    ${bitset_carrier_type} bit_value = string_to_bit_with_check(p_${type_name.lowercaseCamel}.substr(start_of_string));
    if (!bit_value)
        return ${type_name.UppercaseCamel}(0);
    value |= bit_value;
    return ${type_name.UppercaseCamel}(value);
}
    
std::string ${type_name.UppercaseCamel}::to_string() const
{
    std::stringstream buffer;
    unsigned bit_number = 0;
    const char * separator = "";
    for (${bitset_carrier_type} tmp = m_${type_name.lowercaseCamel}; tmp; tmp >>= 1)
    {
        if (tmp & 1)
        {
            buffer << separator << m_${type_name.lowercaseCamel}Names[bit_number];
            separator = " | ";
        }
        ++ bit_number;
    }
    return buffer.str();
}

const char* ${type_name.UppercaseCamel}::m_${type_name.lowercaseCamel}Names[] = {
        ${enum_string_values}
};

${type_name.UppercaseCamel}::bit_type ${type_name.UppercaseCamel}::string_to_bit(const std::string & bit_name)
{
    ${bit_from_string_converter_code}    
}

${bitset_carrier_type} ${type_name.UppercaseCamel}::string_to_bit_with_check(std::string bit_name)
{
    static const char* typeOfWhitespaces = " \t\n\r\f\v";
    bit_name.erase(bit_name.find_last_not_of(typeOfWhitespaces) + 1);
    bit_name.erase(0, bit_name.find_first_not_of(typeOfWhitespaces));
    ${type_name.UppercaseCamel}::bit_type val = string_to_bit(bit_name);
    if (std::string(bit_to_string(val)) == bit_name)
    {
        return val;
    }
    else
    {
	return 0;
    }
}

const char * ${type_name.UppercaseCamel}::bit_to_string(${type_name.UppercaseCamel}::bit_type bit_value)
{
    ${bitset_carrier_type} value = bit_value;
    for(unsigned bit_number = 0; value; ++bit_number, value >>= 1)
    {
        if (value & 1)
        {
            return m_${type_name.lowercaseCamel}Names[bit_number];
        }
    }
    return "";

}

