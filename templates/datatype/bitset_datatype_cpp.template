// WARNING: File generated automatically by 'typo'. 
//   copyright:       ${copyright}
//   generated from:  ${source_script_file_name} line ${source_script_file_line}
//   generated at:    ${timestamp}
// Do not modify manually outside spaces marked as manually added by programmer


#include "${header_file_name}"

#include <sstream>

// additional code (manually added by programmer)
${user_code}
// end of additional includes

${class_name} ${class_name}::from_string(const std::string & ${parameter_name}, char separator)
{
    size_t start_of_string = 0;
    ${bitset_carrier_type} value = 0;
    for (int position = ${parameter_name}.find(separator); position != std::string::npos; position = ${parameter_name}.find(separator, start_of_string))
    {
        std::string element = ${parameter_name}.substr(start_of_string, position-start_of_string);
        ${bitset_carrier_type} bit_value = string_to_bit_with_check(element);
        if (!bit_value)
            return ${class_name}(0);
	value |= bit_value;
        start_of_string = position+1;
    }
    ${bitset_carrier_type} bit_value = string_to_bit_with_check(${parameter_name}.substr(start_of_string));
    if (!bit_value)
        return ${class_name}(0);
    value |= bit_value;
    return ${class_name}(value);
}
    
std::string ${class_name}::to_string() const
{
    std::stringstream buffer;
    unsigned bit_number = 0;
    const char * separator = "";
    for (${bitset_carrier_type} tmp = ${member_name}; tmp; tmp >>= 1)
    {
        if (tmp & 1)
        {
            buffer << separator << ${class_names_member_vector}[bit_number];
            separator = " | ";
        }
        ++ bit_number;
    }
    return buffer.str();
}

const char* ${class_name}:: ${class_names_member_vector}[] = {
        ${enum_string_values}
};

${class_bit_type} ${class_name}::string_to_bit(const std::string & bit_name)
{
    ${bit_from_string_converter_code}    
}

${bitset_carrier_type} ${class_name}::string_to_bit_with_check(std::string bit_name)
{
    static const char* typeOfWhitespaces = " \t\n\r\f\v";
    bit_name.erase(bit_name.find_last_not_of(typeOfWhitespaces) + 1);
    bit_name.erase(0, bit_name.find_first_not_of(typeOfWhitespaces));
    ${class_bit_type} val = string_to_bit(bit_name);
    if (std::string(bit_to_string(val)) == bit_name)
    {
        return val;
    }
    else
    {
	return 0;
    }
}

const char * ${class_name}::bit_to_string(${class_bit_type} bit_value)
{
    ${bitset_carrier_type} value = bit_value;
    for(unsigned bit_number = 0; value; ++bit_number, value >>= 1)
    {
        if (value & 1)
        {
            return ${class_names_member_vector}[bit_number];
        }
    }
    return "";

}

