<html>

  <head>
    <link rel="stylesheet" href="typo.css">
  </head>
  
  <body>
    <h1><a href="typo.html">TYPO</a> class reference manual</h1>
      (c) WGan 2021 <a href="https://en.wikipedia.org/wiki/MIT_License">[licence: MIT]</a>
      
    <p>
      This manual do not describe all classes. Specific errors or adapters could
      not be described here or described very brifely. Lets take a look on list
      of classes. In order of appearance:
    <ul>
      <li><a name="typo_base_py"></a><b>typo_base</b> module - definition of all
        base elements of typo like:<ul>
        <li><a href="#typo_error">typo_error</a></li>
        <li><a href="#typo_generator">typo_generator</a></li>
        <li><a href="#typo_converter">typo_converter</a></li>
        </ul>
      <li><a name="typo_core_py"></a><b>typo_core</b> module - core items 
        of typo. Tools from here could be used also outside typo if you find it
        handy.<ul>
        <li><a href="#identifier_not_found">identifier_not_found</a></li>
        <li><a href="#loop_error_when_resolving">loop_error_when_resolving</a></li>
        <li><a href="#module_not_loaded">module_not_loaded</a></li>
        <li><a href="#typo_context">typo_context</a></li>
        </ul>
      <li><a name="typo_inputs_py"></a><b>typo_inputs</b> module - all inputs 
        of the program. Now just one simple input is defined:<ul>
        <li><a href="#file_lines">file lines</a></li>
        </ul></li>
      <li><a name="typo_interpreter_py"></a><b>typo_interpreter</b> module - a 
        module defining the typo interpreter creating output files: <ul>
        <li><a href="#user_code_placeholder_error">user_code_placeholder_error</a></li>
        <li><a _href="#_">user_code_extractor</a></li>
        <li><a href="#template_does_not_exist">template_does_not_exist</a></li>
        <li><a href="#cannot_translate">cannot_translate</a></li>
        <li><a href="#wrong_generator_for_inline">wrong_generator_for_inline</a></li>
        <li><a href="#error_in_generator">error_in_generator</a></li>
        <li><a href="#output_file_generator">output_file_generator</a></li>
        <li><a _href="#_">typo_processor</a></li>
        <li><a _href="#_">exit_typo</a></li>
        <li><a _href="#_">command_processor</a></li>
        </ul></li>
      <li><a name="typo_outputs_py"></a><b>typo_outputs</b> module - all
        output specific clsses including some formatting tools:<ul>
        <li><a href="#output">output</a></li>
        <li><a href="#console_output">console_output</a></li>
        <li><a href="#output_decorator">output_decorator</a></li>
        <li><a _href="#_">line_split_decorator</a></li>
        <li><a href="#text_source">text_source</a></li>
        <li><a href="#indentation">indentation</a></li>
        <li><a _href="#_">prefixing_output_decorator</a></li>
        <li><a _href="#_">sufixing_output_decorator</a></li>
        <li><a _href="#_">indented_output</a></li>
        <li><a href="#string_output">string_output</a></li>
        <li><a href="#file_cannot_be_created">file_cannot_be_created</a>
        <li><a href="#file_output">file_output</a></li>  
        </ul></li>
      <li><a name="typo_tools_py"></a><b>typo_tools</b> module - classes used
        by typo but also usefull for different purposes:<ul>
        <li><a href="#identifier_non_alphanueric_error">identifier_non_alphanueric_error</a></li>
        <li><a href="#identifier_start_with_digit_error">identifier_start_with_digit_error</a></li>
        <li><a href="#identifier_cannot_be_empty">identifier_cannot_be_empty</a></li>
        <li><a href="#identifier_formatter">identifier_formatter</a></li>
        <li><a href="#path_not_specified">path_not_specified</a></li>
        <li><a href="#path_not_found">path_not_found</a></li>
        <li><a href="#file_name_is_not_defined">file_name_is_not_defined</a></li>
        <li><a href="#malformed_file_name">malformed_file_name</a></li>
        <li><a href="#context_reader">context_reader</a></li>
        <li><a _href="#_">placeholders_info</a></li>
        <li><a href="#gen_timestamp">gen_timestamp</a></li>
        <li><a href="#gen_typo_version">gen_typo_version</a></li>
        <li><a href="#gen_user_code">gen_user_code</a></li>        
        <li><a href="#conv_CAPITALIZE_ALL">conv_CAPITALIZE_ALL</a></li>
        <li><a href="#conv_lowercase_with_underscores">conv_lowercase_with_underscores</a></li>
        <li><a href="#conv_UppercaseCamel">conv_UppercaseCamel</a></li>
        <li><a href="#conv_lowercaseCamel">conv_lowercaseCamel</a></li>
        </ul></li>
      </ul>
    And now, alphabetically:
    
    <h2><a name="cannot_translate"></a>cannot_translate 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_interpreter_py"><span class="module">typo_interpreter.py</span></a>
      </h2>
      Error raised when a symbol defining placeholder in template is neither
      a value nor code generator located in one of registered modules. 
    <p>
      This error is raised by <a href="#output_file_generator">output_file_generator</a>.translate_line.

    <h2><a name="console_output"></a>console_output 
      <a href="#output"><span class="parent">(output)</span></a>
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      An output sending values to standard console. Notice, that this output
      adds newline after each portion of data, so it is better to decorate it 
      by <a href="#line_split_decorator">line_split_decorator</a> 
      to avoid newlines added between the writes.
    <p>
      This output was prepared for debugging purposes - to see the result of the
      generation to the console to review them. 

    <h2><a name="context_reader"></a>context_reader 
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Simple class allowing to interpret values from the context for given 
      purposes.
    <p>
      Currently it allow to take path name and file name:
    <ul>
      <li><b>__init__(context)</b> - initializes reader with given 
        <a href="#typo_context">typo_context</a> object</li>
      <li><b>get_path(variable_name)</b> - gets variable value and checks
        if it is valid path name. Variable must exist and must denote proper 
        and exisitng directory. Function also checks if the path
        ends with slash character. If not - function adds it.</li>
      <li><b>get_file_name(variable_name)</b> - gets variable value and 
        checks if it forms valid file name. Existance of file name is not
        tested, just the value is checked for forbidden characters. 
        Value must exist.</li>
      </ul>

    <h2><a name="conv_CAPITALIZE_ALL"></a>conv_CAPITALIZE_ALL 
      <a href="#typo_converter"><span class="parent">(typo_converter)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Converter transforming many word phraze into identifier denoted as capital
      letters with words separated by underscores. Such identiferis are 
      typically used to denote contants or enviroment variables. 
    <p>
      When proper identifier cannot be found because source phraze contain
      non-alphanumeric characters or first word starts with digit - error is
      raised. For non-aplfanumeric error type is 
      <a href="#identifier_non_alphanueric_error">identifier_non_alphanueric_error</a>.
      When first character of passed string is a digit - 
      <a href="#identifier_start_with_digit_error">identifier_start_with_digit_error</a>
      is raised.
    <p>
      This placeholder implementation bases on functionality of class 
      <a href="#identifier_formatter">identifier_formatter</a>.     
      
    <h2><a name="conv_lowercase_with_underscores"></a>conv_lowercase_with_underscores 
      <a href="#typo_converter"><span class="parent">(typo_converter)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Works like <a href="#conv_CAPITALIZE_ALL">conv_CAPITALIZE_ALL</a>, but 
      formats output string as lowercase and with words connected with underscores.
      
    <h2><a name="conv_lowercaseCamel"></a>conv_lowercaseCamel 
      <a href="#typo_converter"><span class="parent">(typo_converter)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Works like <a href="#conv_CAPITALIZE_ALL">conv_CAPITALIZE_ALL</a>, but 
      formats output string as lowercase and with words started by uppercase.
      Words are not separated by space nor unsercore.
      
    <h2><a name="conv_UppercaseCamel"></a>conv_UppercaseCamel 
      <a href="#typo_converter"><span class="parent">(typo_converter)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Works like <a href="#conv_CAPITALIZE_ALL">conv_CAPITALIZE_ALL</a>, but 
      formats output string as uppercase and with words started by uppercase. 
      Words are not separated by space nor unsercore.

    <h2><a name="error_in_generator"></a>error_in_generator 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_interpreter_py"><span class="module">typo_interpreter.py</span></a>
      </h2>
      When generator is called, and error occures inside generator - it is wrapped
      in this error. It is made for reporting programmer errors to the user of
      generator. Such error message allow to find problem inside generator.
    <p>
      This error is raised by <a href="#output_file_generator">output_file_generator</a>.translate_line.

    <h2><a name=file_cannot_be_created></a>file_cannot_be_created 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      Error raised when exception occure while trying to opern file for writing.
    <p>
      This error is raised by <a href="#output_file">output_file</a>.__init__.

    <h2><a name=file_lines></a>file_lines 
      <span class="parent">(list)</parent> 
      <a href="#typo_inputs_py"><span class="module">typo_inputs.py</span></a>
      </h2>
      Simple class helping reading from text file. It works as array of strings, 
      but it is constructed from file name. If file exists - it read whole file 
      and splits it into lines stored in the object.
    <ul>
      <li><b>__init__(file_name)</b> - constructore taking name of the file to 
        read. If file do not exist, the object is createtes as empty list. No
        exception are thrown.
    </ul>
    
    <h2><a name="file_name_is_not_defined"></a>file_name_is_not_defined 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      When uou use context reader to retrieve data having given meaning, you can 
      take the file name from the context variabled. When value is not defined
      context returns None, but when uoy need a file - it is better to raise error.
    <p>
      This error is raised by <a href="#context_reader">context_reader</a>.get_file_name.

    <h2><a name="file_output"></a>file_output
      <a href="#output"><span class="parent">(output)</span></a>
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      Class used to direct output to file on a storage device. 
    <ul>
      <li><b>__init__(file_name)</b> - opens a file with given name. File name
        can contain relative or absolute path.</li>
      <li><b>write(text)</b> - stores text into the file. It just adapt original
        file write</li>
      <li><b>close()</b> - closes file.</li>
      </ul>
      
    <h2><a name="gen_timestamp"></a>gen_timestamp 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Simple code <a href="#typo_generator">generator</a> which generates 
      current timestamp. Timestamp is taken
      at the moment when generator is used. So do not be suprised when two 
      timestamps in the same document are different.
    <p>
      This generator could be used as inlined, because it neither use 
      indentations nor unformatted access to the output.     
      
    <h2><a name="gen_typo_version"></a>gen_typo_version 
      <a href="#typo_generator"><span class="parent">(typo_generator)</span></a> 
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Simple code <a href="#typo_generator">generator</a> which generates 
      version number of typo generator. It can be used in generated files
      to write information about version of typo who create them.
    <p>
      This generator could be used as inlined, because it neither use 
      indentations nor unformatted access to the output.
           
    <h2><a name="gen_user_code"></a>gen_user_code 
      <a href="#typo_generator"><span class="parent">(typo_generator)</span></a> 
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>      
      Simple code <a href="#typo_generator">generator</a> which places back code 
      added manually in output file. When file is generated, typo first 
      checks if the file exists, and reads parts located in place where
      template defines as <i>${user_code}</i>. 
    <p>
      This generator assumes that the output have possibility to 
      write unformatted code, but do not check it.
      
    <h2><a name="identifier_cannot_be_empty"></a>identifier_cannot_be_empty 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
    <p>
      Identifier formatter takes a string 
      containing set of words separated by spaces. This words must allow to form
      proper identifier. It the input data is empty - this error is raised.
    <p>
      This error is raised by <a href="#identifier_formatter">identifier_formatter</a>.__init__.
      
    <h2><a name="identifier_formatter"></a>identifier_formatter 
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      IdentifierFormatter allow to change sentence or a phraze into identifier valid 
      in most of programming languages. Such identifier contain text form passed 
      phraze and removes spaces. Different ways of formatting is returned 
      by various methods.
    <p>
      Phraze is analized in constructor, and the identifier is formed
      by method building the identifier. Phraze must:
    <ul>
      <li>not empty</li>
      <li>contain only alphanumneri characters or underscores</li>
      <li>must not start with digit</li>
    </ul>
      In current version, the class contain methods:
    <ul>
      <li><b>__init__(identifier)</b> - Initializes formatter checking input
        data. All possible errors can happen here. Constructor sets
        the <i>words</i> collection.</li>
      <li><b>CAPITALIZE_ALL(prefix = "", suffix = "")</b> - build identifier by 
        capitalizint all characters and separates its word by underscore. Returned
        identifer can be decorated by prefix and/or suffix. Such indentifiers
        are mainly used to denote constants, enum, preprocessor or system 
        variables.</li>
      <li><b>lowercase_with_underscores(prefix = "", suffix = "")</b> - formats
        idnetifier as set of lowercase words separated by underscores. Good 
        chose for local variable identifers or parameters. As in other functions,
        prefix and suffix can be added.</li>
      <li><b>UppercaseCamel(prefix = "", suffix = "")</b> - Uppercase camel 
        notation - typical way to express class names. As in other functions,
        prefix and suffix can be added.</li>
      <li><b>lowercaseCamel(self, prefix = "", suffix = "")</b> - lowercase camel 
        notation - typical way to express object names and local variables. 
        As in other functions, prefix and suffix can be added.</li>
      </ul>
    And fields:
    <ul>
      <li><b>words</b> - list containinig list of words to form the identifier</li>
      </ul>
   
    <h2><a name="identifier_non_alphanueric_error"></a>identifier_non_alphanueric_error 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Identifier formatter takes a string 
      containing set of words separated by spaces. This words must allow to form
      proper identifier. The text must be formed from alphanumeric characters and must 
      not start from the ditis. Underscore character is also available.
    <p>
      It the input data contain wrong character - this error is raised.
    <p>
      This error is raised by <a href="#identifier_formatter">identifier_formatter</a>.__init__.

    <h2><a name="identifier_not_found"></a>identifier_not_found 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_core_py"><span class="module">typo_core.py</span></a>
      </h2>
      When cannot resolve symbol located in the value to resolve, this error 
      is raised.
    <p>
      This error is raised by <a href="#typo_context">typo_context</a>._translate_text.

    <h2><a name="indentation"></a>indentation 
      <a href="#text_source"><span class="parent">(text_source)</span></a>
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      Class implenting indentation. Indentation step can be set during the 
      construction, but default step, st to populat 4 spaces, also cound be used.
      Instenataion can be increased or decreased. 
    <p>
      It's a simple class:
    <ul>
      <li><b>__init__(step = 4)</b> - sets indentation step</li>
      <li><b>increase()</b> - insrease indent. So simple.</li>
      <li><b>decrease()</b> - decrease indnet </li>
      <li><b>set(amount_of_spaces)</b> - sets the indent. The value of indent 
        is set to the integer value of amount of spaces divided by the step.
        It is simpler in the code then in documentation.</li>
      <li><b>get()</b> - returns chunk of spaces forming current indentation.</li>
     </ul>
           
    <h2><a name="identifier_start_with_digit_error"></a>identifier_start_with_digit_error 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      Error raised by identifier formatter. When the forst character is 
      digit - this error is raised.
    <p>
      This error is raised by <a href="#identifier_formatter">identifier_formatter</a>.__init__.

    <h2><a name="loop_error_when_resolving"></a>loop_error_when_resolving 
      <span class="parent">(typo_error)</parent> 
      <span class="module">typo_core.py</span>
      </h2>
      Error of resolving value containing <i>${name}</i> which value containg 
      another value name - and such chunk of the need of resolving - somewhere
      forms an loop. In such case we have infinite number of steps to obtain 
      the value. This is not higly welcome situation - so error is raised.
    <p>
      This error is raised by <a href="#typo_context">typo_context</a>.get_value.
       
    <h2><a name="malformed_file_name"></a>malformed_file_name 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      When uou use context reader to retrieve data having given meaning, you can 
      take the file name from the context variabled. The value is additionally
      checked by testing if the value points to existing file.
    <p>
      This error is raised by <a href="#context_reader">context_reader</a>.get_file_name.

    <h2><a name="module_not_loaded"></a>module_not_loaded 
      <a href="#typo_generator"><span class="parent">(typo_generator)</span></a> 
      <a href="#typo_core_py"><span class="module">typo_core.py</span></a>
      </h2>
      When module is needed, but the module itself cannot be found - this error 
      is raised. Lack of module could be a problem in the future, so better is 
      to raise error and leave the problem to the caller.
    <p>
      This error is raised by <a href="#typo_context">typo_context</a>.import_module.
           
    <h2><a name="output"></a>output 
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      Just abstract output. Base class for all output classes. 
    <p>
      Outputs can be specialized, but can be also decorated or can use
      some processing. 
    <p>
      Output must have just one method (however can have more):
    <ul>
      <li><b>write(text)</b> - method sending the text to the output. This method 
      is virtual. Derived classes must specify this method.
    </ul>
      In structure of outputs one can find a set of specilized 
      classes like 
    <ul>
      <li><a href="#console_output">console_ouptut</a> - output writing each
        passed value to the console. Notice that this output do not preprocess
        passed strings and "adds" newline after each value. </li>
      <li><a href="#file_output">file_output</a> - writing data into a text 
        file</li>
      <li><a href="#string_output">string_outout</a> - appends values to 
        a string stored inside the object. Usefull when you want to use 
        generated text in your code.</li>
      </ul>
      Outputs can do some preprocessing working as decorators on other outputs:
    <ul>
      <li><a href="#output_decorator">output_decorator</a> - base class for all 
        decorators which works on original outputs, but preprocess the data
        passed to original output.</li>
      <li><a href="#split_line_decorator">split_line_decorator</a> - handy decorator
        which buffers contant and sends to origina output - whole lines
        ended by newline. When data passed to <i>write</i>. Good when you work with
        <a href="#console_output">console_output</a>, but also when you need 
        line indentation and need to add something before or after each line.</li>
      <li><a href="prefixing_output_decorator">prefixing_output_decorator</a> - 
        decorator adding given prefix before each data passed down to decorated
        output. Prefix is defined as object of class 
        <a href="#text_source>text_source</a></li>
      <li><a href="sufixing_output_decorator">sufixing_output_decorator</a> - 
        this decorator adds suffix after each line. Here the suffix is just a 
        normal string. Nothing more complex was not needed. </li>
      <li><a href="indented_output">indented_output</a> - aomplex output 
        allowing also navigation of indenting lines. Usefull when generating 
        formatted code.</li>
      </ul>

    <h2><a name="output_decorator"></a>output_decorator 
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      Decorator which allow decorate output. As parameter it takes original output
      and implements method <i>write</i>, but instead of writing to 
      <a href="#console_output">console</a>, <a href="file_output">file</a>, 
      <a href="#string_output">string</a> or any other location, it writes 
      on the output passed as parameter.
    <p>
      Class defines two methods
    <ul>
      <li><b>__init__(output)</b> - constructor storing decorated output in 
        the field <i>self.output</i>.</li>
      <li><b>write_on_output(text)</b> - function sending text to decorated
        output. It is preferable to use this function instead of dealing
        direclty to <i>self.output</i></li>
      </ul>
      It derives method which need to be implemented as implementation of 
      decorator functionality:
    <ul>
      <li><b>write(text)</b></li>
      </ul>
      You can define your own decorators however it might be usefull when you 
      need to modify code of the typo. 
    <p>
      This class is base class of few formatting decorators implemented as a 
      part of typo:
    <ul>
      <li><a href="#line_split_decorator">line_split_decorator</a> 
        - buffers content of the file up to newline character and then sends 
        whole line to decorated output.</li>
      <li><a href="#prefixing_output_decorator">prefixing_output_decorator</a> 
        - Adds prefix to each passed data. </li>
      <li><a href="#sufixing_output_decorator">sufixing_output_decorator</a> 
        - Adds suffix to each passed data.</li>
      <li><a href="#indented_output">indented_output</a> 
        - Combined decorator which derives from 
        <a href="#line_split_decorator">line_split_decorator</a> adding indent
        as prefix and newline character as each line suffix.</li>
      </ul>  
      
    <h2><a name="output_file_generator"></a>output_file_generator
      <a href="#typo_interpreter_py"><span class="module">typo_interpreter.py</span></a>
      </h2>
      Main class of typo system - this is real output file generator creating
      output file from template. It creates output file copying all content from 
      template, filling placeholders with content set in context or generated
      with <a href="#typo_generator">generators</a>.
    <p>
      Output file generator process the template line by line:
    <ul>
      <li>Line containing constant text are just copied in into output file</li>
      <li>Line starting with '<i>$></i>' are interpreted as orders. This allow 
        to add and preprocess settings or import necessary modules with generators.</li>
      <li>Lines containing only one placeholder generates the code allowing
        generator directly write into the file. </li>
      <li>When more then one placeholder is located in line, or placeholder is
        inside constant content - it is replaced 'inline' - output
        of generator is redirected to string and the content of the string
        is copied into output file. This is why generators used inline cannot 
        use indentation controling methods on output.</li>
      </ul>
      The class has only 3 methods and contructor:
    <ul>
      <li><b>__init__(context)</b> - constructor taking and storing context.</li>
      <li><b>build_source_code(template_file_name, source_code_file_name)</b> - 
        method perforing whole functionality. It takes two parameters. Both are 
        full file name with the path. Template must exist. Output file can exist
        and is owerwritten, but first it is read to scan for manually added
        code. Scan is performed by <a href="#user_code_extractor">user_code_extractor</a></li>
      <li><b>interpret_line(line)</b> - function processing order located in the
        template. Method creates <a href="#command_processor">command_processor</a>
        passing <i>self</i> into its constructor.</li>
      <li><b>translate_line(line, output)</b> - function translation single 
        template line and stores the result on output. Depending on line content, 
        differnet approach to building output is used.</li>
      </ul>
      And one field:
    <ul>
      <li><b>context</b> - repository of all settings needed to generate output 
        files. This repository (of type <a href="#typo_context">typo_context</a>)
        is also passed to generators to give access to parameters.</li>
      </ul>

    <h2><a name="path_not_found"></a>path_not_found 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      When you use context reader to retrieve data having given meaning, you can 
      take the path from the context variabled. When the value is read - it is 
      additionally checked - if it points to existing folder. If not - this error
      happened.
    <p>
      This error is raised by <a href="#context_reader">context_reader</a>.get_path.
    
    <h2><a name="path_not_specified"></a>path_not_specified 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_tools_py"><span class="module">typo_tools.py</span></a>
      </h2>
      When you use context reader to retrieve data having given meaning, you can 
      take the path from the context variabled. Normally, when the variable is not
      defined - None value is returned. When you require a path - sush 
      situation is not desired - so special error is raised. This error.
    <p>
      This error is raised by <a href="#context_reader">context_reader</a>.get_path.
   
    <h2><a name="string_output"></a>string_output
      <a href="#output"><span class="parent">(output)</span></a>
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      Class used to redirect output to a string. This is a way to generate
      text from generators and then use it as other strings.
      It defines just write method, but the internal storage must be initialized
      first:
    <ul>
      <li><b>__init__()</b> - initializes internal string memo by assigning 
        empty string</li>
      <li><b>write(text)</b> - appends given text to the string</li>
      </ul>
      To access the string stored by sybsequent <i>write</i> calls, use direct 
      access to the field:
    <ul>
      <li><b>text</b> - stored text</li>
      </ul>
    
    <h2><a name="template_does_not_exist"></a>template_does_not_exist 
      <a href="#typo_interpreter_py"><span class="module">typo_interpreter.py</span></a>
      </h2>
      This error is raised when user try to build output file, but mistype the 
      template name. This can also be problem of wrong setting of variable
      <i>template_path</i>. Result is: the file with definition of required 
      template cannot be found in the directory set by <i>template_path</i>.
    <p>
      This error is raised by <a href="#output_file_generator">output_file_generator</a>.build_source_code.
      
    <h2><a name="text_source"></a>text_source 
      <a href="#typo_outputs_py"><span class="module">typo_outputs.py</span></a>
      </h2>
      Base class for text sources - object providing texts. It implement only 
      one method:
    <ul>
      <li><b>get()</b> - function which should return the text which is needed
        when the object of this class is in use.</li>
      </ul>
    <p>
      In current version of typo - this class is base of only one class:
    <ul>
      <li><a href="#indentation">indentation</a> - class building chunk of spaces 
      depending on depth of indentation.
      </ul>
            
    <h2><a name="typo_context"></a>typo_context 
      <a href="#typo_core_py"><span class="module">typo_core.py</span></a>
      </h2>
      Typo context is a class of object used for communication between code 
      generators and the user of the program. Her you can store values accessible 
      by the output file generator and generators it calls. Context also provides
      simple processing of values allowng to replace placeholders located in the
      string values. 
    <p>
      Any python values can be stored in context. It does not limit neither type
      nor the complexity of the values. It also do not provide any check of 
      values. When you want to use tem in your generator - provide your own check
      or use <a href="context_reader">context reader</a> 
      class - simple helper which allow to take values and check them.
    <p>
      Context also stores all information needed by the interpreter. It is also 
      responsigle for loading modules with generators and converters, and storing
      additional code loaded when re-generating output files. Feel free to 
      store any values you need to store during a session.
    <p>
      Context object is created once when <a href="typo_processor">typo 
      processor</a> object is created and exists at least till the end of 
      its existance, so you can keep here values which need to survive between
      creation of subsequent output files.
    <p>
      Context provide set of methods getting and getting data from its content:
    <ul>
      <li><b>set_value(name, value)</b> just sets the value. Name should be a 
        string, value can be of any type which could be stored. No preprocessing
        is performed - so the placeholders are stored in value without 
        translation.</li>
      <li><b>get_not_interpreted_value(name)</b> returns the value from the 
        values dictionary without interpreting it. When the value do not exist, 
        None is returned.</li>
      <li><b>get_value(name)</b> main function for reading values. Returns value
        from the dictionary. If the value is string or list of strings, 
        placeholders located inside are interpreted and replaced by values. 
        Plaholders can represent any value name and can be decorated by converter,
        but cannot use generators. When value does not exist - function returns 
        None</li>
      <li><b>pop_user_code()</b> Returns next user code block to store inside 
        the generated file. When no more blocks are available - function returns
        empty string.</li>
      <li><b>import_module(module_name)</b> - loads python code module and adds
        it to the collection of modules to search for generators and 
        converters.</li>
      <li><b>create_object(class_name)</b> - function creating object of the 
        class of given name. When the class is not a part of typo, all loaded
        modules are searched. When class cannot be found, None is returned.
        </li>
      <li><b>_get_value(name)</b> provides technical solution for taking and
        interpreting value</li>
      <li><b>_translate_value(value)</b> translates value when the value is 
        string or list of strings</li>
      <li><b>_strip_and_get_converter(name)</b> - checks if the name contain
        placeholder written after the dot. If yes - function returns
        pair of values - stripped anem and already created converter object.
        If converter is not found - result is the name and None object.
        </li>
      <li><b>_translate_text(text)</b> - translates text by looking for 
        placeholder and replacing it by its value.</li>
      </ul>
    <p>
      You can also directly refer to fields of context:
    <ul>
      <li><b>values</b> dictionary containing all values set by <b>set_value</b>
        functions. Just keeps all values. Feel free to store anything you
        want here. You can also directly access values or remove them.</li>
      <li><b>user_code</b> list of blocks of user code. From this list you can 
        read by function <b>pop_user_code</b>. This list is filled once per 
        byulding output file. When output file already exist, typo reads
        it and try to recognize code added by the user. Such code is stored here 
        before generation of the file.</li>
      <li><b>modules</b> - list of all modules loaded by <b>import_module</b>.
        When context is asked for generator or converter object (function
        <b>create_object</b>)- these modules
        are searched for definition of needed class.</li>
      </ul>    
    
    <h2><a name="typo_converter"></a>typo_converter 
      <a href="#typo_base_py"><span class="module">typo_base.py</span></a>
      </h2>
      Base class for all converter classes. Converters are used when the 
      placeholder contain name of valid converter written after the dot. Converters
      could be defined by the user/author of metacode generating output files. 
      Such metacode contain templates and code written in python - generators, 
      and converters. And converters must derive from this class.
    <p>
      Converter class must implement one function:
    <ul>
      <li><b>convert(text)</b> - function returning text fater conversion</li>
    </ul>
      Class name of the converter must start with <i>conv_</i>
    <p>
      Typo contain few built in converters:
    <ul>
      <li><a href="#conv_CAPITALIZE_ALL">conv_CAPITALIZE_ALL</a> 
        - makes capitalized identifier from a sentence.</li>
      <li><a href="#conv_lowercase_with_underscores">conv_lowercase_with_underscores</a>
        - makes underscored identifier from a sentence.</li>
      <li><a href="#conv_lowercaseCamel">conv_lowercaseCamel</a> 
        - makes lowerace camel named identifier from a sentence.</li>
      <li><a href="#conv_UppercaseCamel">conv_UppercaseCamel</a> 
        - makes uppercase camel named identifier from a sentence.</li>
    </ul>
    
    <h2><a name="typo_error"></a>typo_error
      <span class="parent">(Exception)</span> 
      <a href="#typo_base_py"><span class="module">typo_base.py</span></a>
      </h2>
      Base class of all errors which may happened during creation of output file.
      When you desing your own code generator and you want to inform about any 
      problem like missing or malformed data - raise this excerion and provide
      meaningfull description. Wyo can also set information about the source of
      the error and position of problematic data in the source. If you do not, 
      such information will be added by typo providing information about position 
      of call of you generator in the template.
    <p>
      Class contain two methods:
    <ul>
      <li><b>__init__(message)</b> - constructor setting message</li>
      <li><b>__str__()</b> - method casting the object into string containing
        error message decorated by the position where the error was found (if 
        sych information was provided)
      </ul>
      and three fields:
    <ul>
      <li><b>text</b> - message describing the problem. This should be human 
        readable message, because when typo is run as standalone application 
        this message is reported to the user.</li>
      <li><b>source</b> - information where the problem is located. This should 
        be name of the file with problemating data. When you do not fill this 
        field - it would be set in typo_interpreter to the currently interpreted 
        template file. Also line field will be set to point current line number.
        </li>
      <li><b>line</b> - position in the file. Usually this is the line number
        indicating problematic line in the file pointed by source field.</li>
      </ul>
      When you create your own error, it is better to derive from typo_error and 
      build error message according to the error data in the constructor. In such
      way you can remove building up the error message from your main code.
    <p>
      All errors in typo are created as separate classes:
    <ul>
      <li><a href="#cannot_translate">cannot_translate</a></li>
      <li><a href="#error_in_generator">error_in_generator</a></li>
      <li><a href="#file_name_is_not_defined">file_name_is_not_defined</a></li>
      <li><a href="#identifier_cannot_be_empty">identifier_cannot_be_empty</a></li>
      <li><a href="#identifier_non_alphanueric_error">identifier_non_alphanueric_error</a></li>
      <li><a href="#identifier_not_found">identifier_not_found</a></li>
      <li><a href="#identifier_start_with_digit_error">identifier_start_with_digit_error</a></li>
      <li><a href="#loop_error_when_resolving">loop_error_when_resolving</a></li>
      <li><a href="#malformed_file_name">malformed_file_name</a></li>
      <li><a href="#module_not_loaded">module_not_loaded</a></li> 
      <li><a href="#path_not_found">path_not_found</a></li>
      <li><a href="#path_not_specified">path_not_specified</a></li>
      <li><a href="#template_does_not_exist">template_does_not_exist</a></li>
      <li><a href="#user_code_placeholder_error">user_code_placeholder_error</a></li>
      <li><a href="#wrong_generator_for_inline">wrong_generator_for_inline</a></li>    
      </ul>      
      
    <h2><a name="typo_generator"></a>typo_generator 
      <a href="#typo_base_py"><span class="module">typo_base.py</span></a>
      </h2>
      Base class of code generators. When building output file using template, 
      symbols in a form <i>${name}</i> works as placeholders. Such placeholders 
      can be filled with the code generated by Python written code. Typo takes 
      the <i>name</i> from the placeholder and assumes, that it is the name 
      of the class generating code. Such class should have a form described 
      here.
    <p>
      Generators must have at least one method named <i>generate</i>:
    <ul>
      <li><b>generate(context, output)</b> - the method which need to 
        be written in your own generators. It receives from typo two parameters:
        <ul>
          <li><b><a href="#typo_context">context</a></b> - access to configuration and
            data.</li>
          <li><b><a href="#output">output</a></b> - possibility to write to output.
            This parameter usually gives more functionality, but better to check 
            if the methods you want to use are available. Usually it is 
            enough to check if the output is of type 
            <a href="#indented_output">indented_output</a>. This output is passed when the
            generator is called as the only one element in template file line.
          </ul></li>
      </ul>
      Be carreful and check if the output provides needed functionality. I was
      thinking to check the typo of output in the <i>${user_code}</i> generator, 
      but this generator cannot be used as inlined. Location of placeholder is 
      checked during reading output file - so it is not possible to use it 
      in wrong way.
    <p>
      When developing your own code generators - you should derive from this class.
      Some examples you can find in typo code:
    <ul>
      <li><a href="#gen_timestamp">gen_timestamp</a> - generates current timestemp</li>
      <li><a href="#gen_typo_version">gen_typo_version</a> - places in the
        code version number of this generator.</li>
      <li><a href="#gen_user_code">gen_user_code</a> - writes user code back to 
        the output file</li>
      </ul>
      
    <h2><a name="user_code_placeholder_error"></a>user_code_placeholder_error 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_interpreter_py"><span class="module">typo_interpreter.py</span></a></h2>
      This error just group problems with <i>user_code</i> placeholder in template.
      This placeholder is processed in different way then other placeholders, because
      typo interpreter must read the user code before it starts to write output file.
      This is needed to keep such parts of code when output file is re-generated.
      Error can occure in few situations. The only differnce is the message:
    <ul>
      <li>placeholder is not the only one in a line.</li>
      <li>line before and after are not well recognizable and cannot be used as delimiters</li>
      <li>when analising output file - ending delimiter cannot be found.</li>
    </ul>
      This error is raised by <a href="#user_code_extractor">user_code_extractor</a>.__init__.
      
    <h2><a name="wrong_generator_for_inline"></a>wrong_generator_for_inline 
      <a href="#typo_error"><span class="parent">(typo_error)</span></a>
      <a href="#typo_interpreter_py"><span class="module">typo_interpreter.py</span></a></h2>
      This error is raised when generator raises any kind of error. It usually
      happened, when you use placeholder inside the line containing also other
      content. WHen this placeholder denotes generator which requires indentation
      functionality on the its output.
    <p>
      This error is raised by <a href="#output_file_generator">output_file_generator</a>.translate_line.
  
  </body>
  
</html>